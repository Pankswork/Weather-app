name: CI/CD Pipeline

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/weather-app
  DOCKER_TAG: ${{ github.sha }}
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: weather-app-eks
  NAMESPACE: pythonapp-dev

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
            ${{ env.DOCKER_IMAGE }}:latest

  terraform-and-deploy:
    name: Infrastructure & Kubernetes Deploy
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Setup Helm
        uses: azure/setup-helm@v4.2.0

      - name: Terraform Init & Apply
        run: |
          terraform init
          terraform apply -auto-approve \
            -var="mysql_username=${{ secrets.DB_USERNAME }}" \
            -var="mysql_password=${{ secrets.DB_PASSWORD }}"

      # CRITICAL: This MUST happen before Helm starts
      - name: Update Kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Install AWS Load Balancer Controller
        run: |
          # Dynamically get the VPC ID from AWS
          VPC_ID=$(aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --query "cluster.resourcesVpcConfig.vpcId" --output text)
          
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=${{ env.EKS_CLUSTER_NAME }} \
            --set serviceAccount.create=true \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=$VPC_ID

          # Annotate for IAM permissions
          kubectl annotate serviceaccount aws-load-balancer-controller \
            -n kube-system \
            eks.amazonaws.com/role-arn=arn:aws:iam::668227158023:role/aws-load-balancer-controller-role --overwrite
          
          echo "Waiting for Load Balancer Controller to be ready..."
          kubectl rollout status deployment/aws-load-balancer-controller -n kube-system --timeout=180s

      - name: Deploy to Kubernetes
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          sed -i "s|image: .*|image: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}|g" k8s/deployment.yaml
          
          kubectl apply -f k8s/serviceaccount.yaml
          kubectl apply -f k8s/service.yaml
          kubectl apply -f k8s/deployment.yaml
          
          kubectl rollout status deployment/weather-app -n ${{ env.NAMESPACE }} --timeout=300s
      
      - name: Deploy Monitoring Stack
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          # We add the 'serviceMonitorSelectorNilUsesHelmValues' flag so it finds your app!
          helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
            --namespace monitoring \                  
            --create-namespace \
            --set grafana.service.type=LoadBalancer \
            --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
            --wait

      - name: Get NLB URL
        run: |
          echo "Waiting for AWS to provision the Load Balancer DNS..."
          # Loop until the hostname is actually available
          for i in {1..20}; do
            URL=$(kubectl get svc weather-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$URL" ]; then
              echo "--------------------------------------------------"
              echo "SUCCESS! Your Application is available at:"
              echo "http://$URL"
              echo "--------------------------------------------------"
              exit 0
            fi
            echo "Still waiting... ($i/20)"
            sleep 15
          done
          echo "Timed out waiting for NLB URL."
          exit 1